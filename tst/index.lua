local luagi = require("luagi")
local test_helper = require("test_helper")
local err = nil

describe( "from repo #index", function()
   local index = nil
   local repo = nil
   setup( function()
      test_helper.setup()
      repo = luagi.open( test_helper.path )
      index, err = repo:index()
   end)

   it( "should have result", function()
      assert.is.not_nil( index )
      assert.are.equal( "userdata", type( index ) )
      assert.is.falsy( err )
   end)

   describe( "owner #index", function() 
      it( "should be owned by repo", function()
         assert.are.equal( repo:path(), index:owner():path() )
      end)
   end)
   describe( "caps #index", function() 
      it( "should return a table", function()
         local caps = index:caps()
         assert.is.not_nil( caps )
         for k, v in pairs( caps ) do
            assert.is.False( v )
         end
      end)
   end)
   describe( "__len #index", function() 
      pending("  luagi_index_entrycount ") 
      it( "should have 3 elements", function()
         assert.are.equal( 3, #index )
      end)
   end)
   describe( "by_index #index", function()
      pending("  luagi_index_get_byindex ") 
      it( "should check bounds", function()
         local e, err = index:by_index(0)
         assert.is.falsy( e )
         assert.are.equal( "index out of bounds", err )
         e, err = index:by_index( #index + 1 )
         assert.is.falsy( e )
         assert.are.equal( "index out of bounds", err )
      end)
      it( "should return an entry", function()
         local e, err = index:by_index( #index )
         assert.is.not_nil( e )
         assert.is.falsy( err )
      end)
   end)

end)

describe( "set_caps #index", function() pending("  luagi_index_set_caps ") end)
describe( "write #index", function() pending("  luagi_index_write ") end)
describe( "path #index", function() pending("  luagi_index_path ") end)
describe( "read_tree #index", function() pending("  luagi_index_read_tree ") end)
describe( "write_tree #index", function() pending("  luagi_index_write_tree ") end)
describe( "clear #index", function() pending("  luagi_index_clear ") end)
describe( "by_path #index", function() pending("  luagi_index_get_bypath ") end)
describe( "remove #index", function() pending("  luagi_index_remove ") end)
describe( "remove_directory #index", function() pending("  luagi_index_remove_directory ") end)
describe( "add #index", function() pending("  luagi_index_add ") end)
describe( "entry_stage #index", function() pending("  luagi_index_entry_stage ") end)
describe( "add_by_path #index", function() pending("  luagi_index_add_bypath ") end)
describe( "remove_by_path #index", function() pending("  luagi_index_remove_bypath ") end)
describe( "add_all #index", function() pending("  luagi_index_add_all ") end)
describe( "remove_all #index", function() pending("  luagi_index_remove_all ") end)
describe( "update_all #index", function() pending("  luagi_index_update_all ") end)
describe( "find #index", function() pending("  luagi_index_find ") end)
describe( "conflict_add #index", function() pending("  luagi_index_conflict_add ") end)
describe( "conflict_get #index", function() pending("  luagi_index_conflict_get ") end)
describe( "conflict_remove #index", function() pending("  luagi_index_conflict_remove ") end)
describe( "conflict_cleanup #index", function() pending("  luagi_index_conflict_cleanup ") end)
describe( "has_conflicts #index", function() pending("  luagi_index_has_conflicts ") end)
describe( "iterate_conflict #index", function() pending("luagi_index_conflict_iterator ") end)
